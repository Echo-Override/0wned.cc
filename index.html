<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silhouette of Reverie (Enhanced Starfield)</title>
    <!-- Load Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Font Awesome for the speaker icon -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <style>
        /* --- Ensure HTML and Body use full size of the viewport --- */
        html {
            height: 100%;
        }
        
        /* --- Subtle Background Color Animation (Deep Dark Void) --- */
        @keyframes subtle-color-shift {
            0% { background-color: #000000; }
            25% { background-color: #0C0618; } 
            50% { background-color: #040C18; } 
            75% { background-color: #180C04; } 
            100% { background-color: #000000; }
        }

        body {
            height: 100vh; 
            width: 100%;
            min-height: 100vh;
            
            font-family: 'Inter', sans-serif;
            background-color: #000000; 
            animation: subtle-color-shift 60s infinite alternate; 
            overflow: hidden;
            cursor: default;
            position: relative; 
        }

        /* --- Layout & Core --- */
        #void-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Canvas element replaces the old star-field div --- */
        #star-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
            pointer-events: none;
            opacity: 1; 
            image-rendering: -webkit-optimize-contrast; 
        }
        
        /* --- Splash Screen and Toggle Icon Styles --- */
        #splash-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            transition: opacity 2.8s ease-out; 
            pointer-events: none; 
        }
        
        #splash-icon {
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(0px, 0px) scale(1) translate(-50%, -50%); 
            
            font-size: 6rem;
            color: #ffffff;
            animation: pulse 2s infinite;
            z-index: 1001; 
            cursor: pointer;
            
            will-change: transform, opacity;
            transition: transform 3s ease, opacity 1s ease-out; 
        }
        
        /* Update pulse keyframes to match the new base transform structure */
        @keyframes pulse {
            0% { transform: translate(0px, 0px) scale(1) translate(-50%, -50%); opacity: 0.8; }
            50% { transform: translate(0px, 0px) scale(1.1) translate(-50%, -50%); opacity: 1.0; }
            100% { transform: translate(0px, 0px) scale(1) translate(-50%, -50%); opacity: 0.8; }
        }
        
        /* Hover state for the transformed splash icon in the corner */
        .corner-toggle-hover:hover {
            opacity: 1.0 !important;
        }
    </style>
</head>
<body class="">

    <!-- Audio Element -->
    <audio id="ambient-audio" loop>
        <!-- In a real deployment, you would replace this with a proper sound file -->
        <source src="relaxing-ambient-music.mp3" type="audio/mp3">
    </audio>

    <div id="void-container">
        <!-- Canvas Element for rendering the starfield -->
        <canvas id="star-canvas"></canvas>
    </div>

    <!-- Black Screen Overlay (Fades out to reveal void) -->
    <div id="splash-screen"></div>

    <!-- Center Icon (Start button for music and lights) -->
    <i id="splash-icon" class="fas fa-volume-up"></i>

    <script>
        // --- Configuration ---
        const REFERENCE_MOBILE_AREA = 300000; 
        const REFERENCE_STAR_COUNT = 300; 
        const DENSITY_PER_PIXEL = REFERENCE_STAR_COUNT / REFERENCE_MOBILE_AREA; 
        
        const BREATHING_STAR_RATIO = 0.12; 
        
        const MAX_STAR_COUNT = 1200; 
        const MIN_STAR_COUNT = 150; 
        
        const MAX_STANDARD_OPACITY = 0.20; 

        const DRIFT_SPEED = 0.0015; 
        const TWINKLE_INTERVAL = 150; 
        const FLASH_CHANCE = 0.01; 
        const SMOOTH_FLASH_DURATION = 800; // 800ms for a gentle pulse
        
        const FLIGHT_CHANCE = 0.005; 
        
        const TRANSITION_TIME = 2800; 
        const POST_TRANSITION_DELAY = 100; 
        
        const PARALLAX_SENSITIVITY = 8; 
        
        const FADE_IN_DURATION = 3000; 
        const STAR_RESPAWN_FADE_DURATION = 1500; 
        const SHOOTING_STAR_DURATION = 2000; 
        const TRAIL_HISTORY_LENGTH = 8; 

        // --- Global Elements and State ---
        const canvas = document.getElementById('star-canvas');
        const ctx = canvas.getContext('2d');
        const ambientAudio = document.getElementById('ambient-audio');
        const splashIcon = document.getElementById('splash-icon'); 
        
        let starObjects = []; 
        let animationFrameId = null; 
        let lastTime = 0; 
        let parallaxOffsetX = 0; 
        let parallaxOffsetY = 0; 
        let lastTwinkleTime = 0;
        
        let starfieldAlpha = 0.0; 
        let fadeInStartTime = 0;

        // --- Utility: Set Canvas Size ---
        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // --- Dynamic Star Count Calculation ---
        function calculateDynamicStarCounts() {
            const screenArea = window.innerWidth * window.innerHeight;
            let totalStars = Math.floor(screenArea * DENSITY_PER_PIXEL);
            totalStars = Math.min(MAX_STAR_COUNT, Math.max(MIN_STAR_COUNT, totalStars));
            const breathingStarsCount = Math.floor(totalStars * BREATHING_STAR_RATIO);
            return { totalStars, breathingStarsCount };
        }

        // --- 1. Starfield Generation (DATA STRUCTURES) ---
        function createStars() {
            setCanvasSize(); 
            const counts = calculateDynamicStarCounts();
            const starCount = counts.totalStars;
            
            starObjects = [];
            
            const halfWidth = window.innerWidth / 2;
            const halfHeight = window.innerHeight / 2;
            
            const initialSpawnTime = 0; 
            
            for (let i = 0; i < starCount; i++) {
                const isBreathing = i < counts.breathingStarsCount;
                
                const baseSize = isBreathing ? (Math.random() * 2.0 + 1.5) : (Math.random() * 0.5 + 0.5); 
                const depth = Math.floor(Math.random() * 3) + 1; 
                
                const initialStarPhysicsX = (Math.random() * window.innerWidth) - halfWidth;
                const initialStarPhysicsY = (Math.random() * window.innerHeight) - halfHeight;
                
                const tintRoll = Math.random();
                let color = '#ffffff';
                if (tintRoll < 0.1) {
                    color = '#B3D9FF'; 
                } else if (tintRoll < 0.2) {
                    color = '#CCE5FF'; 
                } 
                
                const starData = {
                    x: initialStarPhysicsX,
                    y: initialStarPhysicsY,
                    depth: depth,
                    size: baseSize,
                    isBreathing: isBreathing,
                    isFlying: false,
                    baseOpacity: isBreathing ? 0.20 : (Math.random() * MAX_STANDARD_OPACITY), 
                    currentOpacity: isBreathing ? 0.20 : (Math.random() * MAX_STANDARD_OPACITY),
                    color: color,
                    flightStart: 0,
                    flightDuration: 0,
                    flightVecX: 0,
                    flightVecY: 0,
                    spawnTime: initialSpawnTime, 
                    flashStart: 0, // NEW: Timestamp when smooth flash starts
                    trailHistory: [] 
                };
                starObjects.push(starData);
            }
        }

        // --- 2. Twinkle, Flash, and Flight Effects (Non-Physics Loop) ---
        function applyStarEffects(currentTime) {
            const deltaTime = currentTime - lastTwinkleTime;

            if (deltaTime > TWINKLE_INTERVAL) {
                lastTwinkleTime = currentTime;

                for (const star of starObjects) {
                    if (star.isFlying) continue;

                    // Twinkle (adjust non-breathing opacity)
                    if (!star.isBreathing && Math.random() < 0.25) {
                        star.currentOpacity = Math.random() * MAX_STANDARD_OPACITY;
                    }

                    // Smooth Flash (start the flash sequence)
                    if (Math.random() < FLASH_CHANCE) {
                        // Only start a flash if one isn't already running
                        if (star.flashStart === 0) { 
                            star.flashStart = currentTime; 
                        }
                    }
                }

                // Star Flight Logic (remains unchanged)
                if (Math.random() < FLIGHT_CHANCE) {
                    const flyingStar = starObjects[Math.floor(Math.random() * starObjects.length)];
                    
                    if (!flyingStar.isFlying) { 
                        flyingStar.isFlying = true; 
                        flyingStar.flightStart = currentTime;
                        flyingStar.flightDuration = SHOOTING_STAR_DURATION; 

                        const angle = Math.random() * 2 * Math.PI;
                        const speed = Math.random() * 0.15 + 0.15; 
                        flyingStar.flightVecX = Math.cos(angle) * speed;
                        flyingStar.flightVecY = Math.sin(angle) * speed;
                    }
                }
            }
        }

        // --- 3. Parallax Movement Handler (Stores offsets) ---
        function handleParallax(e) {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;

            const xNorm = (e.clientX - centerX) / centerX; 
            const yNorm = (e.clientY - centerY) / centerY; 

            parallaxOffsetX = -xNorm * PARALLAX_SENSITIVITY; 
            parallaxOffsetY = -yNorm * PARALLAX_SENSITIVITY;
        }

        // --- 4. Canvas Drawing Function ---
        function drawStars(currentTime) {
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // --- Global Starfield Fade-In Logic ---
            if (starfieldAlpha < 1.0) {
                const elapsed = currentTime - fadeInStartTime;
                const progress = elapsed / FADE_IN_DURATION;
                starfieldAlpha = Math.min(1.0, progress);
            }
            
            ctx.globalAlpha = starfieldAlpha;
            
            const halfWidth = canvasWidth / 2;
            const halfHeight = canvasHeight / 2;

            for (const star of starObjects) {
                
                // --- Parallax Calculation ---
                const parallaxX_D = parallaxOffsetX / star.depth;
                const parallaxY_D = parallaxOffsetY / star.depth;
                
                let screenX = star.x + halfWidth + parallaxX_D;
                let screenY = star.y + halfHeight + parallaxY_D;

                // --- Shooting Star Trail Rendering ---
                if (star.isFlying && star.trailHistory.length > 1) {
                    ctx.shadowBlur = 0; 
                    const trailAlphaMultiplier = 0.5; 
                    
                    for (let i = star.trailHistory.length - 1; i >= 0; i--) {
                        const fragment = star.trailHistory[i];
                        
                        const fragScreenX = fragment.x + halfWidth + parallaxOffsetX / star.depth;
                        const fragScreenY = fragment.y + halfHeight + parallaxOffsetY / star.depth;

                        const fadeFactor = (i / star.trailHistory.length); 
                        const fragmentSize = star.size * 0.8 * fadeFactor; 

                        ctx.fillStyle = star.color.replace('rgb', 'rgba').replace(')', `, ${trailAlphaMultiplier * fadeFactor})`);
                        
                        ctx.beginPath();
                        ctx.arc(Math.round(fragScreenX), Math.round(fragScreenY), fragmentSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // --- Draw the Star Head (if flying, draw brightly and large) ---
                if (star.isFlying) {
                    ctx.fillStyle = `rgba(255, 255, 255, 1.0)`;
                    ctx.shadowBlur = 12; 
                    ctx.shadowColor = 'rgba(255, 255, 255, 1.0)';
                    
                    ctx.beginPath();
                    ctx.arc(Math.round(screenX), Math.round(screenY), star.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    continue; 
                }
                
                // --- SMOOTH FLASH LOGIC ---
                let flashBoost = 0;
                if (star.flashStart > 0) {
                    const elapsedFlash = currentTime - star.flashStart;
                    const progress = elapsedFlash / SMOOTH_FLASH_DURATION;

                    if (progress < 1.0) {
                        // Use a smooth sine curve (0 -> 1 -> 0) for a pulsing effect
                        flashBoost = Math.sin(progress * Math.PI); 
                    } else {
                        // Flash finished
                        star.flashStart = 0;
                    }
                }

                // --- Breathing/Twinkle Opacity ---
                let finalAlpha = star.currentOpacity;
                if (star.isBreathing) {
                    const breathRate = (star.depth * 500) + 5000;
                    // Base breathing
                    finalAlpha = star.baseOpacity + (0.1 * Math.sin(currentTime / breathRate)); 
                }

                // Apply flash boost to opacity and size
                const opacityBoost = flashBoost * 0.8; // Max 80% extra opacity
                finalAlpha = Math.min(1.0, finalAlpha + opacityBoost);
                
                // --- Individual Star Respawn Fade-In Logic ---
                const elapsedSinceSpawn = currentTime - star.spawnTime;
                let starFadeMultiplier = 1.0;

                if (elapsedSinceSpawn < STAR_RESPAWN_FADE_DURATION) {
                    const progress = elapsedSinceSpawn / STAR_RESPAWN_FADE_DURATION;
                    starFadeMultiplier = Math.pow(progress, 2); 
                }
                
                // Apply final opacity and shadow settings
                finalAlpha *= starFadeMultiplier;

                // Use flashBoost for size increase
                const sizeBoost = flashBoost * 1.5; // Up to 1.5 pixels extra size at peak
                const currentSize = star.size + sizeBoost; 

                ctx.fillStyle = star.color.replace('rgb', 'rgba').replace(')', `, ${finalAlpha})`);
                ctx.shadowBlur = currentSize * 2.5; 
                ctx.shadowColor = 'rgba(255, 255, 255, 0.4)'; 
                
                ctx.beginPath();
                ctx.arc(Math.round(screenX), Math.round(screenY), currentSize / 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.globalAlpha = 1.0; 
        }
        
        // --- 5. Constant Movement Loop (Frame-Rate Independent) ---
        function gameLoop(currentTime) {
            if (lastTime === 0) lastTime = currentTime; 
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime; 
            
            const halfWidth = canvas.width / 2;
            const halfHeight = canvas.height / 2;
            const wrapXLimit = halfWidth * 1.05;
            const wrapYLimit = halfHeight * 1.05;

            starObjects.forEach(star => {
                let starX = star.x;
                let starY = star.y;
                
                const depthFactor = (4 - star.depth); 
                
                // --- Drift Calculation (Outward Movement) ---
                const dirX = starX; 
                const dirY = starY; 
                const distance = Math.sqrt(dirX * dirX + dirY * dirY);
                const driftAmount = DRIFT_SPEED * depthFactor * deltaTime; 
                
                const normX = distance > 0 ? dirX / distance : 0;
                const normY = distance > 0 ? dirY / distance : 0;
                
                starX += normX * driftAmount;
                starY += normY * driftAmount;

                // --- Shooting Star Flight Logic ---
                if (star.isFlying) {
                    starX += star.flightVecX * deltaTime;
                    starY += star.flightVecY * deltaTime;

                    // Add current position to trail history
                    star.trailHistory.push({ x: starX, y: starY, time: currentTime });
                    if (star.trailHistory.length > TRAIL_HISTORY_LENGTH) {
                        star.trailHistory.shift(); 
                    }
                    
                    // Check if flight duration is over
                    if (currentTime > star.flightStart + star.flightDuration) {
                         star.isFlying = false;
                         star.trailHistory = []; // Clear the trail
                    }

                } else {
                    if(star.trailHistory.length > 0) star.trailHistory = [];
                }

                // --- Wrapping Logic (Full-Screen Random Spawn) ---
                if (Math.abs(starX) > wrapXLimit || Math.abs(starY) > wrapYLimit) {
                    
                    star.spawnTime = currentTime; 

                    star.isFlying = false; 
                    star.trailHistory = [];

                    const side = Math.floor(Math.random() * 4); 
                    
                    if (side === 0) { // Top
                        starX = (Math.random() * wrapXLimit * 2) - wrapXLimit; 
                        starY = -wrapYLimit;
                    } else if (side === 1) { // Right
                        starX = wrapXLimit; 
                        starY = (Math.random() * wrapYLimit * 2) - wrapYLimit; 
                    } else if (side === 2) { // Bottom
                        starX = (Math.random() * wrapXLimit * 2) - wrapXLimit;
                        starY = wrapYLimit;
                    } else { // Left
                        starX = -wrapXLimit;
                        starY = (Math.random() * wrapYLimit * 2) - wrapYLimit;
                    }
                }
                
                star.x = starX;
                star.y = starY;
            });
            
            applyStarEffects(currentTime);
            drawStars(currentTime);

            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // --- 6. Audio Control and Toggle Behavior ---

        function toggleAudio() {
            if (ambientAudio.paused) {
                ambientAudio.play().then(() => {
                    splashIcon.classList.remove('fa-volume-mute');
                    splashIcon.classList.add('fa-volume-up');
                }).catch(e => {
                    console.error("Audio playback failed on toggle:", e);
                    splashIcon.classList.remove('fa-volume-up');
                    splashIcon.classList.add('fa-volume-mute');
                });
            } else {
                ambientAudio.pause();
                splashIcon.classList.remove('fa-volume-up');
                splashIcon.classList.add('fa-volume-mute');
            }
        }

        function startExperience() {
            const splashScreen = document.getElementById('splash-screen');
            
            splashIcon.style.animation = 'none';
            void splashIcon.offsetWidth;
            
            createStars();
            fadeInStartTime = performance.now(); 
            
            // --- ICON POSITION (BOTTOM RIGHT) AND SMOOTH TRANSITION ---
            const targetScale = 0.3;
            const iconEstimatedSize = 96; 
            const MARGIN = 48; 
            const scaledIconSize = iconEstimatedSize * targetScale;
            const centerScreenX = window.innerWidth / 2;
            const centerScreenY = window.innerHeight / 2;
            const targetCenterX = window.innerWidth - MARGIN - (scaledIconSize / 2); 
            const targetCenterY = window.innerHeight - MARGIN - (scaledIconSize / 2); 
            const translateX = Math.round(targetCenterX - centerScreenX); 
            const translateY = Math.round(targetCenterY - centerScreenY); 

            splashIcon.style.transform = 
                `translate(${translateX}px, ${translateY}px) scale(${targetScale}) translate(-50%, -50%)`;
            
            splashIcon.style.opacity = '0.2'; 
            splashIcon.classList.add('corner-toggle-hover');

            
            // --- SPLASH SCREEN FADE OUT ---
            splashScreen.style.opacity = '0'; 
            
            ambientAudio.play().catch(e => {
                console.error("Audio playback failed (Autoplay restrictions):", e);
            });
            
            animationFrameId = requestAnimationFrame(gameLoop); 

            // PHASE 2: Cleanup and Event Listeners
            setTimeout(() => {
                window.addEventListener('mousemove', handleParallax);

                splashScreen.style.display = 'none'; 
                splashIcon.removeEventListener('click', startExperience);
                splashIcon.addEventListener('click', toggleAudio);
            }, TRANSITION_TIME + POST_TRANSITION_DELAY);
        }

        // --- Initialization ---
        window.onload = function () {
            setCanvasSize(); 
            document.getElementById('splash-icon').addEventListener('click', startExperience, { once: true });
        };
        
        // --- Responsive Handling ---
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                if (document.getElementById('splash-screen').style.opacity === '0') {
                    setCanvasSize(); 
                    createStars(); 
                }
            }, 250); 
        });

    </script>
</body>
</html>
